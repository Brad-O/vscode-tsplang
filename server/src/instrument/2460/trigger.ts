/*
 *  Copyright 2018 Tektronix Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
/* tslint:disable:max-line-length */
'use strict'

import { CompletionItem, CompletionItemKind, MarkupKind, ParameterInformation, SignatureInformation } from 'vscode-languageserver'

const triggerCompletions: Array<CompletionItem> = [
    {
        detail: 'This function clears the blender event detector and resets the overrun indicator of blender N.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets the blender event detector to the undetected state and resets the overrun indicator of the event detector.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.blender[N].clear',
    },
    {
        detail: 'This attribute selects whether the blender performs OR operations or AND operations.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command selects whether the blender waits for any one event (OR) or waits for all selected events (AND) before signaling an output event.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.blender[N].orenable',
    },
    {
        detail: 'This attribute indicates whether or not an event was ignored because of the event detector state.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Indicates if an event was ignored because the event detector was already in the detected state when the event occurred. This is an indication of the state of the event detector that is built into the event blender itself.\n\nThis command does not indicate if an overrun occurred in any other part of the trigger model or in any other trigger object that is monitoring the event. It also is not an indication of an action overrun.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.blender[N].overrun',
    },
    {
        detail: 'This function resets some of the trigger blender settings to their factory defaults.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The trigger.blender[N].reset() function resets the following attributes to their factory defaults:\n\nIt also clears trigger.blender[N].overrun.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.blender[N].reset',
    },
    {
        detail: 'This attribute specifies the events that trigger the blender.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'There are four stimulus inputs that can each select a different event.\n\nUse zero to disable the blender input.\n\nThe event parameter may be any of the trigger events shown in the following table.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.blender[N].stimulus[M]',
    },
    {
        detail: 'This function waits for a blender trigger event to occur.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This function waits for an event blender trigger event. If one or more trigger events were detected since the last time trigger.blender[N].wait() or trigger.blender[N].clear() was called, this function returns immediately.\n\nAfter detecting a trigger with this function, the event detector automatically resets and rearms. This is true regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.blender[N].wait',
    },
    {
        detail: 'This function clears any pending command triggers.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'A command trigger indicates if a trigger event has been detected over a command interface since the last trigger.wait() command was sent. Command triggers are generated by:\n\ntrigger.clear() clears the command triggers and discards the history of trigger events.\n\n'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.clear',
    },
    {
        detail: 'This function clears the trigger event on a digital input line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The event detector of a trigger enters the detected state when an event is detected. For the specified trigger line, this command clears the event detector, discards the history, and clears the overrun status(sets the overrun status to false).'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.digin[N].clear',
    },
    {
        detail: 'This attribute sets the edge used by the trigger event detector on the given trigger line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets the logic on which the trigger event detector and the output trigger generator operate on the specified trigger line.\n\nTo directly control the line state, set the mode of the line to digital and use the write command. When the digital line mode is set for open drain, the edge settings assert a TTL lowâ€‘pulse.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.digin[N].edge',
    },
    {
        detail: 'This attribute returns the event detector overrun status.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If this is true, an event was ignored because the event detector was already in the detected state when the event occurred.\n\nThis is an indication of the state of the event detector built into the line itself. It does not indicate if an overrun occurred in any other part of the trigger model or in any other detector that is monitoring the event.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.digin[N].overrun',
    },
    {
        detail: 'This function waits for a trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This function pauses for up to timeout seconds for an input trigger. If one or more trigger events are detected since the last time trigger.digin[N].wait() or trigger.digin[N].clear() was called, this function returns a value immediately. After waiting for a trigger with this function, the event detector is automatically reset and is ready to detect the next trigger. This is true regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.digin[N].wait',
    },
    {
        detail: 'This function asserts a trigger pulse on one of the digital I/O lines.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Initiates a trigger event and does not wait for completion. The pulse width that is set determines how long the instrument asserts the trigger.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.digout[N].assert',
    },
    {
        detail: 'This attribute sets the output logic of the trigger event generator to positive or negative for the specified line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This attribute controls the logic that the output trigger generator uses on the given trigger line.\n\nThe output state of the digital I/O line is controlled by the trigger logic, and the user-specified output state of the line is ignored.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.digout[N].logic',
    },
    {
        detail: 'This attribute describes the length of time that the trigger line is asserted for output triggers.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Setting the pulse width to zero (0) seconds asserts the trigger indefinitely. To release the trigger line, use trigger.digout[N].release().'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.digout[N].pulsewidth',
    },
    {
        detail: 'This function releases an indefinite length or latched trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Releases a trigger that was asserted with an indefinite pulsewidth time. It also releases a trigger that was latched in response to receiving a synchronous mode trigger. Only the specified trigger line is affected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.digout[N].release',
    },
    {
        detail: 'This attribute selects the event that causes a trigger to be asserted on the digital output line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The digital trigger pulsewidth command determines how long the trigger is asserted.\n\nThe trigger stimulus for a digital I/O line can be set to one of the trigger events that are described in the following table.\n\n'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.digout[N].stimulus',
    },
    {
        detail: 'This function clears the event detector for a LAN trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The trigger event detector enters the detected state when an event is detected. This function clears a trigger event detector and discards the previous of the trigger packet.\n\nThis function clears all overruns associated with this LAN trigger.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.lanin[N].clear',
    },
    {
        detail: 'This attribute sets the trigger operation and detection mode of the specified LAN event.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command controls how the trigger event detector and the output trigger generator operate on the given trigger. These settings are intended to provide behavior similar to the digital I/O triggers.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.lanin[N].edge',
    },
    {
        detail: 'This attribute contains the overrun status of the LAN event detector.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command indicates whether an event has been ignored because the event detector was already in the detected state when the event occurred.\n\nThis is an indication of the state of the event detector built into the synchronization line itself. It does not indicate if an overrun occurred in any other part of the trigger model, or in any other construct that is monitoring the event.\n\nIt also is not an indication of an output trigger overrun.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.lanin[N].overrun',
    },
    {
        detail: 'This function waits for an input trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If one or more trigger events have been detected since the last time trigger.lanin[N].wait() or trigger.lanin[N].clear() was called, this function returns immediately.\n\nAfter waiting for a LAN trigger event with this function, the event detector is automatically reset and rearmed regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.lanin[N].wait',
    },
    {
        detail: 'This function simulates the occurrence of the trigger and generates the corresponding event.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Generates and sends a LAN trigger packet for the LAN event number specified.\n\nSets the pseudo line state to the appropriate state.\n\nThe following indexes provide the listed LXI events:'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.lanout[N].assert',
    },
    {
        detail: 'This function prepares the event generator for outgoing trigger events.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command prepares the event generator to send event messages. For TCP connections, this opens the TCP connection.\n\nThe event generator automatically disconnects when either the protocol or IP address for this event is changed.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.lanout[N].connect',
    },
    {
        detail: 'This attribute contains the LAN event connection state.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This is set to true when the LAN trigger is connected and ready to send trigger events after a successful trigger.lanout[N].connect()  command. If the LAN trigger is not ready to send trigger events, this value is false.\n\nThis attribute is also false when the trigger.lanout[N].protocol or trigger.lanout[N].ipaddress attribute is changed or when the remote connection closes the connection.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.lanout[N].connected',
    },
    {
        detail: 'This function disconnects the LAN trigger event generator.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this command is set for TCP connections, this closes the TCP connection.\n\nThe LAN trigger automatically disconnects when either the trigger.lanout[N].protocol or trigger.lanout[N].ipaddress attributes for this event are changed.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.lanout[N].disconnect',
    },
    {
        detail: 'This attribute specifies the address (in dottedâ€‘decimal format) of UDP or TCP listeners.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Sets the IP address for outgoing trigger events.\n\nAfter you change this setting, you must send the connect command before outgoing messages can be sent.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.lanout[N].ipaddress',
    },
    {
        detail: 'This attribute sets the logic on which the trigger event detector and the output trigger generator operate on the given trigger line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: ''
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.lanout[N].logic',
    },
    {
        detail: 'This attribute sets the LAN protocol to use for sending trigger messages.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The LAN trigger listens for trigger messages on all the supported protocols. However, it uses the designated protocol for sending outgoing messages.\n\nAfter you change this setting, you must re-connect the LAN trigger event generator before you can send outgoing event messages.\n\nWhen multicast is selected, the trigger IP address is ignored and event messages are sent to the multicast address 224.0.23.159.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.lanout[N].protocol',
    },
    {
        detail: 'This attribute specifies events that cause this trigger to assert.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This attribute specifies which event causes a LAN trigger packet to be sent for this trigger. Set the event to one of the existing trigger events, which are shown in the following table.\n\nSetting this attribute to none disables automatic trigger generation.\n\nIf any events are detected before the trigger LAN connection is sent, the event is ignored and the action overrun is set.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.lanout[N].stimulus',
    },
    {
        detail: 'This function stops all trigger model commands on the instrument.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this command is received, the instrument stops the trigger model.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.abort',
    },
    {
        detail: 'This function returns the settings for all trigger model blocks.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This returns the settings for the trigger model.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.getblocklist',
    },
    {
        detail: 'This function returns the count value of the trigger model counter block.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command returns the counter value. When the counter is active, this returns the present count. If the trigger model has started or is running but has not yet reached the counter block, this value is 0.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.getbranchcount',
    },
    {
        detail: 'This function starts the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: ''
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.initiate',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that uses source and measure configuration lists.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This trigger model template incorporates a source configuration list and measure configuration list. You must set up the configuration lists before loading the trigger model.\n\nYou can also set a delay and change the reading buffer.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” Config List',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that makes continuous measurements for a specified amount of time.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When you load this predefined trigger model, you can specify amount of time to make a measurement and the length of the delay before the measurement.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” Duration Loop',
    },
    {
        detail: 'This function clears the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When you load this predefined trigger model, any blocks that have been defined in the trigger model are cleared so the trigger model has no blocks defined.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” Empty',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that sets up a grading operation.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This trigger model template allows you to grade components and place them into up to four bins, based on the comparison to limits.\n\nTo set a limit as unused, set the high value for the limit to be less than the low limit.\n\nAll limit patterns and the pass pattern are sent on digital I/O lines 1 to 4, where 1 is the least significant bit.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” GradeBinning',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that sets up a logic trigger through the digital I/O.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This trigger model waits for a digital input event to occur, makes a measurement, and issues a notify event. The notify event asserts a digital output line.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.\n\nThis command replaces the trigger.model.load() â€” ExternalTrigger command, which is deprecated.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” LogicTrigger',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that makes continuous measurements until the specified event occurs.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The event constant is the event that ends infinite triggering or ends readings set to occur before the trigger and start post-trigger readings. The trigger model makes readings until it detects the event constant. After the event, it makes a finite number of readings, based on the setting of the trigger position.\n\nThe position marks the location in the reading buffer where the trigger will occur. The position is set as a percentage of the active buffer capacity. The buffer captures measurements until a trigger occurs. When the trigger occurs, the buffer retains the percentage of readings specified by the position, then captures remaining readings until 100 percent of the buffer is filled. For example, if this is set to 75 for a reading buffer that holds 10,000 readings, the trigger model makes 2500 readings after it detects the source event. There will be 7500 pre-trigger readings and 2500 postâ€‘trigger readings.\n\nThe instrument makes two sets of readings. The first set is made until the trigger event occurs. The second set is made after the trigger event occurs, up to the number of readings calculated by the position parameter.\n\nYou cannot have the event constant set at none when you run this predefined trigger model.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” LoopUntilEvent',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that does a specific number of measurements.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets up a loop that sets a delay, makes a measurement, and then repeats the loop the number of times you define in the count parameter.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” SimpleLoop',
    },
    {
        detail: 'This function loads a predefined trigger model configuration that sets up a sorting operation.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This trigger model template allows you to sort components and place them into up to four bins, based on the comparison to limits.\n\nTo set a limit as unused, set the high value for the limit to be less than the low limit.\n\nAll limit patterns and the all fail pattern are sent on digital I/O lines 1 to 4, where 1 is the least significant bit.\n\nAfter selecting a trigger model template, you can view the trigger model blocks in a graphical format by pressing the frontâ€‘panel MENU key and under Trigger, selecting Configure. You can also add or delete blocks and change trigger model settings from this screen. You can use the trigger.model.getblocklist() command to view the trigger model blocks in a list format.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.load() â€” SortBinning',
    },
    {
        detail: 'This function defines a trigger model block that always goes to a specific block.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When the trigger model reaches a branchâ€‘always building block, it goes to the building block set by branchToBlock.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ALWAYS',
    },
    {
        detail: 'This function defines a trigger model block that branches to a specified block a specified number of times.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command defines a trigger model building block that branches to another block using a counter to iterate a specified number of times.\n\nCounters increment every time the trigger model reaches them until they are more than or equal to the count value. At that point, the trigger model continues to the next building block in the sequence.\n\nThe counter is reset to 0 when the trigger model starts. It is incremented each time trigger model execution reaches the counter block.\n\nIf you are using remote commands, you can query the counter. The counter is incremented immediately before the branch compares the actual counter value to the set counter value. Therefore, the counter is at 0 until the first comparison. When the trigger model reaches the set counter value, branching stops and the counter value is one greater than the setting.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_COUNTER',
    },
    {
        detail: 'This function defines a trigger model block that goes to a specified block if the difference of two measurements meets preset criteria.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This block calculates the difference between the last two measurements from a measure block. It subtracts the most recent measurement from the previous measurement.\n\nThe difference between the measurements is compared to the target difference. If the difference is less than the target difference, the trigger model goes to the specified branching block. If the difference is more than the target difference, the trigger model proceeds to the next block in the trigger block sequence.\n\nIf you do not define the measure block, it will compare measurements of a measure block that precedes the branch delta block. For example, if you have a measure block, a wait block, another measure block, another wait block, and then the branch delta block, the delta block compares the measurements from the second measure block. If a preceding measure block does not exist, an error occurs.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_DELTA',
    },
    {
        detail: 'This function defines a trigger model block that goes to a specified block if a measurement meets preset criteria.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The type of limit can be:\n\nThe measurement block must be a measure building block that occurs in the trigger model before the branchâ€‘onâ€‘constantâ€‘limits block. The last measurement from a measure building block is used.\n\nIf the limit A is more than the limit B, the values are automatically swapped so that the lesser value is used as the lower limit.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_LIMIT_CONSTANT',
    },
    {
        detail: 'This function defines a trigger model block that goes to a specified block in the trigger model if a measurement meets userâ€‘defined criteria.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The measure block must occur in the trigger model before the branchâ€‘onâ€‘dynamicâ€‘limits block. If no measure block is defined, the measurement from the previous measure block is used. If no previous measure block exists, an error is reported.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_LIMIT_DYNAMIC',
    },
    {
        detail: 'This function causes the trigger model to branch to a specified building block the first time it is encountered in the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The branch-once building block branches to a specified block the first time trigger model execution encounters the branchâ€‘once block. If it is encountered again, the trigger model ignores the block and continues in the normal sequence.\n\nThe once block is reset when trigger model execution reaches the idle state. Therefore, the branchâ€‘once block always executes the first time the trigger model execution encounters this block.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ONCE',
    },
    {
        detail: 'This function defines a trigger model block that causes the trigger model to go to a specified building block every time the trigger model encounters it, except for the first time.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The branchâ€‘onceâ€‘excluded block is ignored the first time the trigger model encounters it. After the first encounter, the trigger model goes to the specified branching block.\n\nThe branchâ€‘onceâ€‘excluded block is reset when the trigger model starts or is placed in idle.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ONCE_EXCLUDED',
    },
    {
        detail: 'This function branches to a specified block when a specified trigger event occurs.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If you set the branch event to none, an error is generated when you run the trigger model.\n\nThe following table shows the constants for the events.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ON_EVENT',
    },
    {
        detail: 'This function defines a trigger model block that clears the reading buffer.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When trigger model execution reaches the buffer clear trigger block, the instrument empties the specified reading buffer. The specified buffer can be the default buffer or a buffer that you defined.\n\nIf you are clearing a userâ€‘defined reading buffer, you must create the buffer before you define this block.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_BUFFER_CLEAR',
    },
    {
        detail: 'This function recalls the settings at the next index of a source or measure configuration list.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The configuration list must be defined before you can use this block.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_NEXT',
    },
    {
        detail: 'This function defines a trigger model block that recalls the settings stored at the previous index in a source or measure configuration list.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: ''
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_PREV',
    },
    {
        detail: 'This function recalls the system settings that are stored in a source or measure configuration list.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When the trigger model reaches a configuration recall building block, the settings in the specified configuration list are recalled.\n\nYou can restore a specific set of configuration settings in the configuration list by defining the index.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_RECALL',
    },
    {
        detail: 'This function adds a constant delay to the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When trigger model execution reaches a delay block, it stops normal measurement and trigger model operation for the amount of time set by the delay. Background measurements continue to be made, and if any previously executed block started infinite measurements, they also continue to be made.\n\nIf other delays have been set, this delay is in addition to the other delays.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_DELAY_CONSTANT',
    },
    {
        detail: 'This function adds a delay to the execution of the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Each measure function can have up to 5 unique user delay times (M1 to M5). Each source function can also have up to 5 unique user delay times (S1 to S5). The delay time is set by the userâ€‘delay command, which is only available over a remote interface.\n\nThough the trigger model can be used with any function, the user delay is set per function. Make sure you are setting the delay for the function you intend to use with the trigger model.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_DELAY_DYNAMIC',
    },
    {
        detail: 'This function defines a trigger model block that sets the lines on the digital I/O port high or low.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The bit mask defines the bits in the pattern that are driven high or low. A binary 1 in the bit mask indicates that the corresponding I/O line should be driven according to the bit pattern. To drive all lines, specify all ones (63, 0x3F, 0b111111) or omit this parameter. If the bit for a line in the bit pattern is set to 1, the line is driven high. If the bit is set to 0 in the bit pattern, the line is driven low.\n\nFor this block to work as expected, make sure you configure the trigger type and line state of the digital line for use with the trigger model (use the digital line mode command).'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_DIGITAL_IO',
    },
    {
        detail: 'This function allows you to log an event in the event log when the trigger model is running.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Note that using this block too often in a trigger model could overflow the event log. It may also take away from the time needed to process more critical trigger model blocks.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_LOG_EVENT',
    },
    {
        detail: 'This function defines a trigger block that makes a measurement.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When you set the count to a finite value, trigger model execution remains at the block until all measurements are complete. If you set the count to infinite, the trigger model executes subsequent blocks and measurements continue in the background until the trigger model execution reaches another measure block or until the trigger model ends.\n\nYou must select a measure function before running a trigger model that contains this block.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_MEASURE',
    },
    {
        detail: 'This function creates a placeholder that performs no action in the trigger model; available only using remote commands.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If you remove a trigger model block, you can use this block as a placeholder for the block number so that you do not need to renumber the other blocks.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_NOP',
    },
    {
        detail: 'This function defines a trigger model block that generates a trigger event and immediately continues to the next block.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Other commands can reference the event that the notify block generates. This assigns a stimulus somewhere else in the system. For example, you can use the notify event as the stimulus of a hardware trigger line, such as a digital I/O line.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_NOTIFY',
    },
    {
        detail: 'This function creates a block in the trigger model that resets a branch counter to 0.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When the trigger model reaches the Counter Reset block, it resets the count of the specified Branch on Counter block to zero.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_RESET_BRANCH_COUNT',
    },
    {
        detail: 'This function defines a trigger block that turns the output source on or off.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: ''
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_SOURCE_OUTPUT',
    },
    {
        detail: 'This function defines a trigger model block that waits for an event before allowing the trigger model to continue.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The following table shows the constants for the events.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.setblock() â€” trigger.BLOCK_WAIT',
    },
    {
        detail: 'This function returns the present state of the trigger model.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command returns the state of the trigger model. The instrument checks the state of a started trigger model every 100ms.\n\nThis command returns the trigger state and the block that the trigger model last executed.\n\nThe trigger model states are:'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.model.state',
    },
    {
        detail: 'This function clears the timer event detector and overrun indicator for the specified trigger timer number.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets the timer event detector to the undetected state and resets the overrun indicator.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.timer[N].clear',
    },
    {
        detail: 'This attribute sets the number of events to generate each time the timer generates a trigger event or is enabled as a timer or alarm.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If count is set to a number greater than 1, the timer automatically starts the next trigger timer delay at the expiration of the previous delay.\n\nSet count to zero (0) to cause the timer to generate trigger events indefinitely.\n\nIf you use the trigger timer with a trigger model, make sure the count value is the same or more than any count values expected in the trigger model.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].count',
    },
    {
        detail: 'This attribute sets and reads the timer delay.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Once the timer is enabled, each time the timer is triggered, it uses this delay period.\n\nAssigning a value to this attribute is equivalent to:\n\nThis creates a delay list of one value.\n\nReading this attribute returns the delay interval that will be used the next time the timer is triggered.\n\nIf you use the trigger timer with a trigger model, make sure the trigger timer delay is set so that the readings are paced correctly.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].delay',
    },
    {
        detail: 'This attribute sets an array of timer intervals.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Each time the timer is triggered after it is enabled, it uses the next delay period from the array. The default value is an array with one value of 10 ms.\n\nAfter all elements in the array have been used, the delays restart at the beginning of the list.\n\nIf the array contains more than one element, the average of the delay intervals in the list must be Â³50Âµs.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].delaylist',
    },
    {
        detail: 'This attribute enables the trigger timer.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this command is set to on, the timer performs the delay operation.\n\nWhen this command is set to off, there is no timer on the delay operation.\n\nYou must enable a timer before it can use the delay settings or the alarm configuration. For expected results from the timer, it is best to disable the timer before changing a timer setting, such as delay or start seconds.\n\nTo use the timer as a simple delay or pulse generator with digital I/O lines, make sure the timer start time in seconds and fractional seconds is configured for a time in the past. To use the timer as an alarm, configure the timer start time in seconds and fractional seconds for the desired alarm time.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].enable',
    },
    {
        detail: 'This function resets trigger timer settings to their default values.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The trigger.timer[N].reset() function resets the following attributes to their default values:\n\nIt also clears trigger.timer[N].overrun.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.timer[N].reset',
    },
    {
        detail: 'This attribute configures the fractional seconds of an alarm or a time in the future when the timer will start.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command configures the alarm of the timer.\n\nWhen the timer is enabled, the timer starts immediately if the timer is configured for a start time that has passed.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].start.fractionalseconds',
    },
    {
        detail: 'This attribute specifies when timer events are generated.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this is set to on, a trigger event is generated immediately when the timer is triggered.\n\nWhen it is set to off, a trigger event is generated when the timer elapses. This generates the event trigger.EVENT_TIMERN.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].start.generate',
    },
    {
        detail: 'This attribute indicates if an event was ignored because of the event detector state.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command indicates if an event was ignored because the event detector was already in the detected state when the event occurred.\n\nThis is an indication of the state of the event detector built into the timer itself. It does not indicate if an overrun occurred in any other part of the trigger model or in any other construct that is monitoring the delay completion event. It also is not an indication of a delay overrun.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.timer[N].start.overrun',
    },
    {
        detail: 'This attribute configures the seconds of an alarm or a time in the future when the timer will start.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command configures the alarm of the timer.\n\nWhen the timer is enabled, the timer starts immediately if the timer is configured for a start time that has passed.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].start.seconds',
    },
    {
        detail: 'This attribute describes the event that starts the trigger timer.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Set this attribute any trigger event to start the timer when that event occurs.\n\nSet this attribute to zero (0) to disable event processing and use the timer as a timer or alarm based on the start time.\n\nTrigger events are described in the table below.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.timer[N].start.stimulus',
    },
    {
        detail: 'This function waits for a trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If one or more trigger events were detected since the last time trigger.timer[N].wait() or trigger.timer[N].clear() was called, this function returns immediately.\n\nAfter waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.timer[N].wait',
    },
    {
        detail: 'This function clears the event detector for a LAN trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The trigger event detector enters the detected state when an event is detected. When this command is sent, the instrument does the following actions:'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.tsplinkin[N].clear',
    },
    {
        detail: 'This attribute indicates which trigger edge controls the trigger event detector for a trigger line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When the edge is detected, the instrument asserts a TTLâ€‘low pulse for the output.\n\nThe output state of the I/O line is controlled by the trigger logic. The user-specified output state of the line is ignored.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.tsplinkin[N].edge',
    },
    {
        detail: 'This attribute indicates if the event detector ignored an event while in the detected state.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command indicates whether an event has been ignored because the event detector was already in the detected state when the event occurred.\n\nThis is an indication of the state of the event detector built into the synchronization line itself.\n\nIt does not indicate if an overrun occurred in any other part of the trigger model, or in any other construct that is monitoring the event. It also is not an indication of an output trigger overrun.'
        },
        kind: CompletionItemKind.Constant,
        label: 'trigger.tsplinkin[N].overrun',
    },
    {
        detail: 'This function waits for a trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This function waits up to the timeout value for an input trigger. If one or more trigger events are detected since the last time this command or trigger.tsplinkin[N].clear() was called, this function returns immediately.\n\nAfter waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.tsplinkin[N].wait',
    },
    {
        detail: 'This function simulates the occurrence of the trigger and generates the corresponding trigger event.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Initiates a trigger event and does not wait for completion. The set pulse width determines how long the trigger is asserted.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.tsplinkout[N].assert',
    },
    {
        detail: 'This attribute defines the trigger output with output logic for a trigger line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This attribute controls the logic that the output trigger generator uses on the given trigger line.\n\nThe output state of the digital I/O line is controlled by the trigger logic, and the user-specified output state of the line is ignored.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.tsplinkout[N].logic',
    },
    {
        detail: 'This attribute sets the length of time that the trigger line is asserted for output triggers.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Setting the pulse width to 0 asserts the trigger indefinitely.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.tsplinkout[N].pulsewidth',
    },
    {
        detail: 'This function releases a latched trigger on the given TSPâ€‘Link trigger line.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Releases a trigger that was asserted with an indefinite pulse width. It also releases a trigger that was latched in response to receiving a synchronous mode trigger.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.tsplinkout[N].release',
    },
    {
        detail: 'This attribute specifies the event that causes the synchronization line to assert a trigger.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'To disable automatic trigger assertion on the synchronization line, set this attribute to trigger.EVENT_NONE.\n\nDo not use this attribute when triggering under script control. Use trigger.tsplinkout[N].assert() instead.\n\nThe event parameters that you can use are described in the table below.'
        },
        kind: CompletionItemKind.Property,
        label: 'trigger.tsplinkout[N].stimulus',
    },
    {
        detail: 'This function waits for a trigger event.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This function waits up to timeout seconds for a trigger on the active command interface. A command interface trigger occurs when:\n\nIf one or more of these trigger events were previously detected, this function returns immediately.\n\nAfter waiting for a trigger with this function, the event detector is automatically reset and rearmed. This is true regardless of the number of events detected.'
        },
        kind: CompletionItemKind.Function,
        label: 'trigger.wait',
    },
]

const triggerSignatures: Array<SignatureInformation> = [
    SignatureInformation.create(
        'trigger.blender[N].clear(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The blender number (1 or 2).'
        ),
    ),
    SignatureInformation.create(
        'trigger.blender[N].reset(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The trigger event blender (1 or 2).'
        ),
    ),
    SignatureInformation.create(
        'trigger.blender[N].wait(triggered, N, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'Trigger detection indication for blender.'
        ),
        ParameterInformation.create(
            'N',
            'The trigger blender (1 or 2) on which to wait.'
        ),
        ParameterInformation.create(
            'timeout',
            'Maximum amount of time in seconds to wait for the trigger blender event.'
        ),
    ),
    SignatureInformation.create(
        'trigger.digin[N].clear(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'Digital I/O trigger line (1 to 6).'
        ),
    ),
    SignatureInformation.create(
        'trigger.digin[N].wait(triggered, N, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'Trigger detected: true\nNo triggers detected during the timeout period: false.'
        ),
        ParameterInformation.create(
            'N',
            'Digital I/O trigger line (1 to 6).'
        ),
        ParameterInformation.create(
            'timeout',
            'Timeout in seconds.'
        ),
    ),
    SignatureInformation.create(
        'trigger.digout[N].assert(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'Digital I/O trigger line (1 to 6).'
        ),
    ),
    SignatureInformation.create(
        'trigger.digout[N].release(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'Digital I/O trigger line (1 to 6).'
        ),
    ),
    SignatureInformation.create(
        'trigger.lanin[N].clear(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The LAN event number (1 to 8) to clear.'
        ),
    ),
    SignatureInformation.create(
        'trigger.lanin[N].wait(triggered, N, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'Trigger detection indication (true or false).'
        ),
        ParameterInformation.create(
            'N',
            'The trigger packet over LAN to wait for (1 to 8).'
        ),
        ParameterInformation.create(
            'timeout',
            'Maximum amount of time in seconds to wait for the trigger event.'
        ),
    ),
    SignatureInformation.create(
        'trigger.lanout[N].assert(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The LAN event number (1 to 8).'
        ),
    ),
    SignatureInformation.create(
        'trigger.lanout[N].connect(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The LAN event number (1 to 8).'
        ),
    ),
    SignatureInformation.create(
        'trigger.lanout[N].disconnect(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The LAN event number (1 to 8).'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.getbranchcount(blockNumber)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” Config List(measureConfigList, sourceConfigList, delay, bufferName)',
        undefined,
        ParameterInformation.create(
            'measureConfigList',
            'A string that contains the name of the measurement configuration list to use.'
        ),
        ParameterInformation.create(
            'sourceConfigList',
            'A string that contains the name of the source configuration list to use.'
        ),
        ParameterInformation.create(
            'delay',
            'The delay time before each measurement (167ns to 10ks); default is 0 for no delay.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the reading buffer, which may be a default buffer (defbuffer1 or defbuffer2) or a userâ€‘defined buffer; defaults to defbuffer1..'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” Duration Loop(duration, delay, bufferName)',
        undefined,
        ParameterInformation.create(
            'duration',
            'The amount of time for which to make measurements (167 ns to 100ks).'
        ),
        ParameterInformation.create(
            'delay',
            'The delay time before each measurement (167ns to 10ks); default is 0 for no delay.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the reading buffer, which may be a default buffer (defbuffer1 or defbuffer2) or a userâ€‘defined buffer; defaults to defbuffer1.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” GradeBinning(x, x)',
        undefined,
        ParameterInformation.create(
            'x',
            'x is limit 1, 2, 3, or 4; the upper limit that the measurement is compared against.'
        ),
        ParameterInformation.create(
            'x',
            'x is 1, 2, 3, or 4; the lower limit that the measurement is compared against.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” LogicTrigger(digInLine, digOutLine, count, clear, delay, bufferName)',
        undefined,
        ParameterInformation.create(
            'digInLine',
            'The digital input line (1 to 6); also the event that the trigger model will wait on in block1.'
        ),
        ParameterInformation.create(
            'digOutLine',
            'The digital output line (1 to 6).'
        ),
        ParameterInformation.create(
            'count',
            'The number of measurements the instrument will make.'
        ),
        ParameterInformation.create(
            'clear',
            'To clear previously detected trigger events when entering the wait block: trigger.CLEAR_ENTER\nTo immediately act on any previously detected triggers and not clear them (default): trigger.CLEAR_NEVER.'
        ),
        ParameterInformation.create(
            'delay',
            'The delay time before each measurement (167ns to 10ks); default is 0 for no delay.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the reading buffer, which may be a default buffer (defbuffer1 or defbuffer2) or a userâ€‘defined buffer; defaults to defbuffer1.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” LoopUntilEvent(triggerEvent, position, clear, bufferName)',
        undefined,
        ParameterInformation.create(
            'triggerEvent',
            'The event that ends infinite triggering or readings set to occur before the trigger; see Details.'
        ),
        ParameterInformation.create(
            'position',
            'The number of readings to make in relation to the size of the reading buffer; enter as a percentage (0% to 100%).'
        ),
        ParameterInformation.create(
            'clear',
            'To clear previously detected trigger events when entering the wait block (default): trigger.CLEAR_ENTER\nTo immediately act on any previously detected triggers and not clear them: trigger.CLEAR_NEVER.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the reading buffer, which may be a default buffer (defbuffer1 or defbuffer2) or a userâ€‘defined buffer; defaults to defbuffer1.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” SimpleLoop(count, delay, bufferName)',
        undefined,
        ParameterInformation.create(
            'count',
            'The number of measurements the instrument will make.'
        ),
        ParameterInformation.create(
            'delay',
            'The delay time before each measurement (167ns to 10ks); default is 0 for no delay.'
        ),
        ParameterInformation.create(
            'bufferName',
            'A string that indicates the reading buffer; the default buffers (defbuffer1 or defbuffer2) or the name of a userâ€‘defined buffer; if no buffer is specified, defbuffer1 is used.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.load() â€” SortBinning(x, x)',
        undefined,
        ParameterInformation.create(
            'x',
            'x is limit 1, 2, 3, or 4; the upper limit that the measurement is compared against.'
        ),
        ParameterInformation.create(
            'x',
            'x is 1, 2, 3, or 4; the lower limit that the measurement is compared against.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ALWAYS(blockNumber, branchToBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number to execute when the trigger model reaches the Always block.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_COUNTER(blockNumber, targetCount, branchToBlock, targetCount)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'targetCount',
            'The number of times to repeat.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the counter is less than the targetCount value.'
        ),
        ParameterInformation.create(
            'targetCount',
            'branchToBlock.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_DELTA(blockNumber, targetDifference, branchToBlock, targetDifference, measureBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'targetDifference',
            'The value against which the block compares the difference between the measurements.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the difference between the measurements is less than or equal to the targetDifference.'
        ),
        ParameterInformation.create(
            'targetDifference',
            'branchToBlock.'
        ),
        ParameterInformation.create(
            'measureBlock',
            'The block number of the measure block that makes the measurements to be compared; if this is 0 or undefined, the trigger model uses the previous measure block.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_LIMIT_CONSTANT(blockNumber, limitType, limitA, limitType, limitB, limitType, branchToBlock, measureBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'limitType',
            'The type of limit, which can be one of the following types:\ntrigger.LIMIT_ABOVE\ntrigger.LIMIT_BELOW\ntrigger.LIMIT_INSIDE\ntrigger.LIMIT_OUTSIDE.'
        ),
        ParameterInformation.create(
            'limitA',
            'The lower limit that the measurement is tested against; if  limitType is set to:\ntrigger.LIMIT_ABOVE: This value is ignored\ntrigger.LIMIT_BELOW: The measurement must be below this value\ntrigger.LIMIT_INSIDE: The low limit that the measurement is compared against\ntrigger.LIMIT_OUTSIDE: The low limit that the measurement is compared against.'
        ),
        ParameterInformation.create(
            'limitType',
            'limitA.'
        ),
        ParameterInformation.create(
            'limitB',
            'The upper limit that the measurement is tested against; if  limitType is set to:\ntrigger.LIMIT_ABOVE: The measurement must be above this value\ntrigger.LIMIT_BELOW: This value is ignored\ntrigger.LIMIT_INSIDE: The high limit that the measurement is compared against\ntrigger.LIMIT_OUTSIDE: The high limit that the measurement is compared against.'
        ),
        ParameterInformation.create(
            'limitType',
            'limitB.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the measurement meets the defined criteria.'
        ),
        ParameterInformation.create(
            'measureBlock',
            'The block number of the measure block that makes the measurements to be compared; if this is 0 or undefined, the trigger model uses the previous measure block.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_LIMIT_DYNAMIC(blockNumber, limitType, branchToBlock, measureBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'limitType',
            'The type of limit, which can be one of the following types:\ntrigger.LIMIT_ABOVE\ntrigger.LIMIT_BELOW\ntrigger.LIMIT_INSIDE\ntrigger.LIMIT_OUTSIDE.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the measurement meets the criteria set in the configuration list.'
        ),
        ParameterInformation.create(
            'measureBlock',
            'The block number of the measure block that makes the measurements to be compared; if this is 0 or undefined, the trigger model uses the previous measure block.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ONCE(blockNumber, branchToBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the trigger model first encounters this block.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ONCE_EXCLUDED(blockNumber, branchToBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the trigger model encounters this block after the first encounter.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BRANCH_ON_EVENT(blockNumber, event, branchToBlock)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'event',
            'The event that must occur before the trigger model branches the specified block.'
        ),
        ParameterInformation.create(
            'branchToBlock',
            'The block number of the trigger model block to execute when the specified event occurs.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_BUFFER_CLEAR(blockNumber, bufferName)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the buffer, which must be an existing buffer; if no buffer is defined, defbuffer1 is used.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_NEXT(blockNumber, configurationList)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'configurationList',
            'A string that defines the source or measure configuration list to recall.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_PREV(blockNumber, configurationList)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'configurationList',
            'A string that defines the source or measure configuration list to recall.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_CONFIG_RECALL(blockNumber, configurationList, index)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'configurationList',
            'A string that defines the source or measure configuration list to recall.'
        ),
        ParameterInformation.create(
            'index',
            'The index in the configuration list to recall; default is 1.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_DELAY_CONSTANT(blockNumber, time)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'time',
            'The amount of time to delay in seconds (167 ns to 10 ks, or 0 for no delay).'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_DELAY_DYNAMIC(blockNumber, blockNumber, userDelay, userDelay, n, n, n, n, N, n, n, n, n, N, N)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'blockNumber',
            'blockNumber.'
        ),
        ParameterInformation.create(
            'userDelay',
            'The number of the user delay:\ntrigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N]\ntrigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
        ParameterInformation.create(
            'userDelay',
            'userDelay.'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N]trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
        ParameterInformation.create(
            'n',
            'The number of the user delay:.'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N].'
        ),
        ParameterInformation.create(
            'N',
            'trigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N]trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
        ParameterInformation.create(
            'n',
            'The number of the user delay:.'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N]trigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N].'
        ),
        ParameterInformation.create(
            'n',
            'trigger.USER_DELAY_Mn, where n is the number of the user delay (1 to 5) set by smu.measure.userdelay[N].'
        ),
        ParameterInformation.create(
            'N',
            'The number of the user delay:.'
        ),
        ParameterInformation.create(
            'N',
            'trigger.USER_DELAY_Sn, where n is the number of the user delay (1 to 5) set by smu.source.userdelay[N].'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_DIGITAL_IO(blockNumber, bitPattern, bitMask)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'bitPattern',
            'Sets the value that specifies the output line bit pattern (0 to 63).'
        ),
        ParameterInformation.create(
            'bitMask',
            'Specifies the bit mask; if omitted, all lines are driven (0 to 63).'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_LOG_EVENT(blockNumber, eventNumber, N, N, N, N, message)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'eventNumber',
            'The event number:\ntrigger.LOG_INFON\ntrigger.LOG_WARNN\ntrigger.LOG_ERRORN\nWhere N is 1 to 4; you can define up to four of each type\nYou can also set trigger.LOG_WARN_ABORT, which aborts the trigger model immediately and posts a warning event log message.'
        ),
        ParameterInformation.create(
            'N',
            'You can also set trigger.LOG_WARN_ABORT, which aborts the trigger model immediately and posts a warning event log message.'
        ),
        ParameterInformation.create(
            'N',
            'The event number:.'
        ),
        ParameterInformation.create(
            'N',
            'You can also set trigger.LOG_WARN_ABORT, which aborts the trigger model immediately and posts a warning event log message.'
        ),
        ParameterInformation.create(
            'N',
            'eventNumber.'
        ),
        ParameterInformation.create(
            'message',
            'A string up to 31 characters.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_MEASURE(blockNumber, bufferName, count)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'bufferName',
            'The name of the buffer, which must be an existing buffer; if no buffer is defined, defbuffer1 is used.'
        ),
        ParameterInformation.create(
            'count',
            'The number of readings to make before moving to the next block in the trigger model; set to a specific value or infinite (trigger.COUNT_INFINITE) or stop infinite (trigger.COUNT_STOP).'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_NOP(blockNumber)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_NOTIFY(blockNumber, N)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'N',
            'The identification number of the notification; 1 to 8.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_RESET_BRANCH_COUNT(blockNumber, counter)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'counter',
            'The block number of the counter that is to be reset.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_SOURCE_OUTPUT(blockNumber, state)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'state',
            'Turn the source off: smu.OFF\nTurn the source on: smu.ON.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.setblock() â€” trigger.BLOCK_WAIT(blockNumber, event, clear, logic)',
        undefined,
        ParameterInformation.create(
            'blockNumber',
            'The sequence of the block in the trigger model.'
        ),
        ParameterInformation.create(
            'event',
            'The event that must occur before the trigger block allows trigger execution to continue (see Details).'
        ),
        ParameterInformation.create(
            'clear',
            'To clear previously detected trigger events when entering the wait block: trigger.CLEAR_ENTER\nTo immediately act on any previously detected triggers and not clear them (default): trigger.CLEAR_NEVER.'
        ),
        ParameterInformation.create(
            'logic',
            'If each event must occur before the trigger model continues: trigger.WAIT_AND\nIf at least one of the events must occur before the trigger model continues: trigger.WAIT_OR.'
        ),
    ),
    SignatureInformation.create(
        'trigger.model.state(status, n)',
        undefined,
        ParameterInformation.create(
            'status',
            'The status of the trigger model:\ntrigger.STATE_IDLE\ntrigger.STATE_RUNNING\ntrigger.STATE_WAITING\ntrigger.STATE_EMPTY\ntrigger.STATE_BUILDING\ntrigger.STATE_FAILED\ntrigger.STATE_ABORTING\ntrigger.STATE_ABORTED.'
        ),
        ParameterInformation.create(
            'n',
            'The last trigger model block that was executed.'
        ),
    ),
    SignatureInformation.create(
        'trigger.timer[N].clear(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'Trigger timer number (1 to 4).'
        ),
    ),
    SignatureInformation.create(
        'trigger.timer[N].reset(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'Trigger timer number (1 to 4).'
        ),
    ),
    SignatureInformation.create(
        'trigger.timer[N].wait(triggered, N, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'Trigger detection indication.'
        ),
        ParameterInformation.create(
            'N',
            'Trigger timer number (1 to 4).'
        ),
        ParameterInformation.create(
            'timeout',
            'Maximum amount of time in seconds to wait for the trigger.'
        ),
    ),
    SignatureInformation.create(
        'trigger.tsplinkin[N].clear(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The trigger line (1 to 3) to clear.'
        ),
    ),
    SignatureInformation.create(
        'trigger.tsplinkin[N].wait(triggered, N, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'Trigger detection indication; set to one of the following values:\ntrue: A trigger is detected during the timeout period\nfalse: A trigger is not detected during the timeout period.'
        ),
        ParameterInformation.create(
            'N',
            'The trigger line (1 to 3).'
        ),
        ParameterInformation.create(
            'timeout',
            'The timeout value in seconds.'
        ),
    ),
    SignatureInformation.create(
        'trigger.tsplinkout[N].assert(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The trigger line (1 to 3).'
        ),
    ),
    SignatureInformation.create(
        'trigger.tsplinkout[N].release(N)',
        undefined,
        ParameterInformation.create(
            'N',
            'The trigger line (1 to 3).'
        ),
    ),
    SignatureInformation.create(
        'trigger.wait(triggered, timeout)',
        undefined,
        ParameterInformation.create(
            'triggered',
            'A trigger was detected during the timeout period: true\nNo triggers were detected during the timeout period: false.'
        ),
        ParameterInformation.create(
            'timeout',
            'Maximum amount of time in seconds to wait for the trigger.'
        ),
    ),
]

export async function getTriggerCompletions(): Promise<Array<CompletionItem>> {
    return new Promise<Array<CompletionItem>>((
        resolve: (value?: Array<CompletionItem>) => void,
        reject: (reason?: Error) => void
    ): void => {
            try {
                resolve(triggerCompletions)
            }
            catch (e) {
                reject(new Error(e.toString()))
            }
    })
}

export async function getTriggerSignatures(): Promise<Array<SignatureInformation>> {
    return new Promise<Array<SignatureInformation>>((
        resolve: (value?: Array<SignatureInformation>) => void,
        reject: (reason?: Error) => void
    ): void => {
        try {
            resolve(triggerSignatures)
        }
        catch (e) {
            reject(new Error(e.toString()))
        }
    })
}
