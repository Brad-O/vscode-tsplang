/* tslint:disable:max-line-length */
'use strict'

import { CompletionItem, CompletionItemKind, MarkupKind, ParameterInformation, SignatureInformation } from 'vscode-languageserver'

const scanCompletions: Array<CompletionItem> = [
    {
        detail: 'This function adds channels to the scan list.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Use this function to add channels to the present scan list. If the scan list does not exist, it also creates a scan list.\n\nChannels are added to the end of the present list in the order in which they are specified in the channel list.\n\nIf you include a configuration list, the configuration list must exist before you send this command.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.add',
    },
    {
        detail: 'This function allows you to include multiple channels in a single scan step.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command adds a list of channels to be closed simultaneously in a single step of a scan.\n\nIf you need to make measurements using multiple functions on these channels, you can use the configuration list parameter to call the function settings. The configuration list must be created before calling it in this command.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.addsinglestep',
    },
    {
        detail: 'This attribute determines if the scan sends a trigger event when a value is out of limits.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this is set on, a trigger is generated when the measurements exceed the limits set for the channels in the scan. To use this trigger, set a stimulus to trigger.EVENT_SCAN_ALARM_LIMIT.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.alarmnotify',
    },
    {
        detail: 'This attribute defines which buffer is used with the scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This selects the buffer that stores the data generated by the scan.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.buffer',
    },
    {
        detail: 'This attribute indicates whether the first channel of the scan waits for the channel stimulus event to be satisfied before closing.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When bypass is set to on and the start stimulus for the scan is set to wait for a stimulus, the first channel of the scan closes when the scan starts (the stimulus setting is ignored).\n\nFor other channels, the channel stimulus must be satisfied before the channel action takes place.\n\nWhen bypass is set to off, every channel (including the first) must satisfy the start stimulus setting before the channel action occurs for that step.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.bypass',
    },
    {
        detail: 'This attribute determines which trigger event causes the channel action to occur.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Set the event ID to one of the options in the following table.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.channel.stimulus',
    },
    {
        detail: 'This function deletes the existing scan list and creates a new list of channels to scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The items in the channel list are scanned in the order listed.\n\nSending this command with no parameters clears the existing scan list.\n\nUsing a configuration list allows you to set multiple functions for the channels using the settings in the configuration list. The configuration list must exist before you send this command.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.create',
    },
    {
        detail: 'This command stores data from a scan to a file on a USB flash drive.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets up the instrument to export scan data. If an option to export data is selected, data is sent to a USB flash drive inserted into the USB port on the front panel of the instrument. Export files are limited to 500MB. When data exceeds 500MB, another file is created with _n added to the file name, where n starts at 1 and is incremented for each additional file.\n\nThe filename must specify the full path (including /usb1/). If included, the file extension must be set to .csv. If no file extension is specified, .csv is added.\n\nFor options that save more than one item of time information, each item is comma-delimited. For example, the default format is date, time, and fractional seconds for each reading.\n\nThe exported data is time-stamped.\n\nExporting data can impact scan performance. The more often exports occur, the more the impact on performance. Therefore, exporting data at completion of each step results in the slowest performance.\n\nThe DMM6500 does not check for existing files when you save. Verify that you are using a unique name to avoid overwriting any existing CSV files on the flash drive.\n\nYou can OR the buffer.COL_CHANNEL, buffer.COL_CSV_CHAN_COLS, and buffer.COL_CSV_EASY_GRAPH options with the timestamp options (buffer.COL_TIME_ABSOLUTE, buffer.COL_TIME_PARTS, buffer.COL_TIME_RAW, buffer.COL_TIME_RELATIVE, and buffer.COL_TIMESTAMP_READING).\n\nYou cannot use buffer.COL_CSV_CHAN_COLS if when is set to scan.WRITE_AFTER_STEP.\n\nYou cannot use buffer.COL_CSV_EASY_GRAPH if when is set to scan.WRITE_AFTER_STEP or scan.WRITE_AFTER_SCAN.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.export',
    },
    {
        detail: 'This function calculates alarm limits based on the present configuration of the system.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Auto Learn runs a scan and establishes alarm limits based on the measurements from the scan. Make sure your system is in a stable state before running Auto Learn.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.learnlimits',
    },
    {
        detail: 'This function returns a list that includes the initial open or close state of any cards installed in the instrument and the settings at each step of the scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command lists the existing scan list, including each step in the scan and information for step, open, or close status.\n\nIf the scan list is empty, the return is EMPTY.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.list',
    },
    {
        detail: 'This attribute specifies the interval time between measurement requests.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command specifies the time between measurements in the scan.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.measure.interval',
    },
    {
        detail: 'This attribute selects the trigger for the measurement.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Use this to start a set of measurement count readings that are triggered by a single event.\n\nThe available trigger events are described in the following table.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.measure.stimulus',
    },
    {
        detail: 'This attribute sets the relay action when the scan starts.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'When this attribute is set to open all, channels on all slots are opened before a scan starts.\n\nWhen the mode is set to open used, an intelligent open is performed. For channels that are not set to a function:\n\nIf any step is set to a function:\n\nWhen this attribute is set to automatic backplane relay, it is equivalent to setting open used, except that all required backplane relays are closed before the start of the scan. These backplane relays are not opened or closed during the scan and do not open at the end of the scan.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.mode',
    },
    {
        detail: 'This attribute defines which channel to monitor for a limit to be reached before starting the scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The channel to monitor for a limit to be reached before starting the scan.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.monitor.channel',
    },
    {
        detail: 'This attribute specifies the high limit to be used by the scan monitor.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets the high limit for the monitor.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.monitor.limit.high.value',
    },
    {
        detail: 'This attribute defines the low limit to be used by the scan monitor.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command sets the low limit for the monitor.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.monitor.limit.low.value',
    },
    {
        detail: 'This attribute determines if a scan starts immediately when triggered or after measurements reach a set value.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This command determines if measurements are monitored to start a scan. If measurements are monitored, it also determines if the measurement triggers the start of the scan when it reaches a high value, low value, or either.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.monitor.mode',
    },
    {
        detail: 'This function causes a scan to automatically restart if it was interrupted by a power failure.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If the restart option is set on, the scan settings are saved in memory immediately after the scan is triggered and before the scan operation begins. All scan settings, including watched channels, need to be in place before the scan starts. Any changes that are made after the scan starts are not recalled if the power is lost and the scan needs to restart.\n\nIf the restart option is on and power is lost, when power is restored, the scan restarts. The scan setup that was in place when the scan started becomes the power-up setup. It takes precedence over any other power-up setup. If the scan completes successfully, the scan setup is removed as the power-up setup.\n\nIf the DMM6500 detects that a card was changed during the power-up sequence, restart is set to off, the interrupted scan is not resumed, and an event is generated. The instrument starts up normally.\n\nWhen a scan is automatically restarted, it is logged in the event log.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.restart',
    },
    {
        detail: 'This attribute sets the number of times the scan is repeated.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The scan count attribute setting indicates how many times the scan list is iterated through before the scan completes.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.scancount',
    },
    {
        detail: 'This attribute specifies the interval time between scan starts when the scan count is more than one.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'If the scan interval is less than the time the scan takes to run, the next scan starts immediately when the first scan finishes.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.scaninterval',
    },
    {
        detail: 'This attribute determines which event starts the scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'The events that you can use to start the scan are described in the following table.'
        },
        kind: CompletionItemKind.Property,
        label: 'scan.start.stimulus',
    },
    {
        detail: 'This function provides the present state of a running background scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'Returns the state of the present scan, the scan count, and the step count.\n\nThe scan count is the number of the present iteration through the scan portion of the trigger model. This number does not increment until the scan begins. Therefore, if the instrument is waiting for an input to trigger a scan start, the scan count represents the previous number of scan iterations. If no scan has begun, the scan count is zero.\n\nThe step count is the number of times the scan has completed a pass through the channel action portion of the trigger model. This number does not increment until after the action completes. Therefore, if the instrument is waiting for an input to trigger a channel action, the step count represents the previous step. If no step has yet completed, the step count is zero. If the step count has yet to complete the first step in a subsequent pass through a scan, the scan count represents the last step in the previous scan pass.\n\nThe information from the scan state command may be delayed up to 100ms from the actual state of the scan because of system resources used by the scan.'
        },
        kind: CompletionItemKind.Function,
        label: 'scan.state',
    },
    {
        detail: 'This attribute returns the number of steps in the present scan.',
        documentation: {
            kind: MarkupKind.Markdown,
            value: 'This is set by the number of steps in the active scan list.'
        },
        kind: CompletionItemKind.Constant,
        label: 'scan.stepcount',
    },
]

const scanSignatures: Array<SignatureInformation> = [
    SignatureInformation.create(
        'scan.add(channelList, configList, index)',
        undefined,
        ParameterInformation.create(
            'channelList',
            'List of channels to add, in the order in which they should occur in the scan.'
        ),
        ParameterInformation.create(
            'configList',
            'A string that defines the configuration list to recall.'
        ),
        ParameterInformation.create(
            'index',
            'The index in the configuration list to recall; default is 1.'
        ),
    ),
    SignatureInformation.create(
        'scan.addsinglestep(channelList, configList, index)',
        undefined,
        ParameterInformation.create(
            'channelList',
            'List of channels to add, in the order in which they should occur in the scan.'
        ),
        ParameterInformation.create(
            'configList',
            'A string that defines the configuration list to recall.'
        ),
        ParameterInformation.create(
            'index',
            'The index in the configuration list to recall; default is 1.'
        ),
    ),
    SignatureInformation.create(
        'scan.create(channelList, configList, index)',
        undefined,
        ParameterInformation.create(
            'channelList',
            'String specifying channels to add to the new scan list.'
        ),
        ParameterInformation.create(
            'configList',
            'A string that defines the configuration list to recall.'
        ),
        ParameterInformation.create(
            'index',
            'The index in the configuration list to recall; default is 1.'
        ),
    ),
    SignatureInformation.create(
        'scan.export(filename, when, what)',
        undefined,
        ParameterInformation.create(
            'filename',
            'The name of the file to be created on the USB flash drive.'
        ),
        ParameterInformation.create(
            'when',
            'When to write the data to the file:\nscan.WRITE_AFTER_STEP: At completion of each scan step\nscan.WRITE_AFTER_SCAN: At completion of each scan\nscan.WRITE_AT_END: At completion of all scans\nscan.WRITE_NEVER: Do not write data to a file.'
        ),
        ParameterInformation.create(
            'what',
            'Which data to include; see Details for options.'
        ),
    ),
    SignatureInformation.create(
        'scan.learnlimits(window, iterations)',
        undefined,
        ParameterInformation.create(
            'window',
            'Percentage of deviation from the measurement that is within limits: 0.1 to 1000.'
        ),
        ParameterInformation.create(
            'iterations',
            'Number of times to run the scan to set limits: 1 to 10; default 1.'
        ),
    ),
    SignatureInformation.create(
        'scan.state(scanState, scanCount, stepCount)',
        undefined,
        ParameterInformation.create(
            'scanState',
            'The present state of the scan running in the background. Possible states include:\nscan.EMPTY: Scan is not set up\nscan.BUILDING: The DMM6500 is building the scan\nscan.RUNNING: The scan is running the trigger model portion of the scan\nscan.STEPPING: The scan is running the channel action portion of the scan\nscan.ABORTED: The scan was canceled\nscan.PAUSED: The scan was paused\nscan.FAILED: The scan failed\nscan.SUCCESS: The scan completed successfully.'
        ),
        ParameterInformation.create(
            'scanCount',
            'The number of scans that have completed.'
        ),
        ParameterInformation.create(
            'stepCount',
            'The number of steps that have completed.'
        ),
    ),
]

export async function getScanCompletions(): Promise<Array<CompletionItem>> {
    return new Promise<Array<CompletionItem>>((
        resolve: (value?: Array<CompletionItem>) => void,
        reject: (reason?: Error) => void
    ): void => {
            try {
                resolve(scanCompletions)
            }
            catch (e) {
                reject(new Error(e.toString()))
            }
    })
}

export async function getScanSignatures(): Promise<Array<SignatureInformation>> {
    return new Promise<Array<SignatureInformation>>((
        resolve: (value?: Array<SignatureInformation>) => void,
        reject: (reason?: Error) => void
    ): void => {
        try {
            resolve(scanSignatures)
        }
        catch (e) {
            reject(new Error(e.toString()))
        }
    })
}
